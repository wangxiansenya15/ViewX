登录校验代码重构方向
我看了一下 
AuthenticationService.java，确实存在耦合度高和职责不清的问题。以下是具体的改进方向（建议在后续迭代中实施）：

A. 去除 HttpSession 依赖（无状态化）
现状：目前使用 session.getAttribute("verificationCode") 存储验证码。这在分布式部署（多实例）下会失效，且违背RESTful 无状态原则。
改进：使用 Redis 存储验证码。
Key: auth:code:{email}
Value: 123456
TTL: 5分钟
这样服务重启或扩容都不影响验证。

B. 参数校验解耦
现状：Service 层充斥着大量的 if (email == null) 判断。
改进：使用 Spring Validation (@Valid, @NotBlank)。
在 UserDTO 或 LoginRequest 对象字段上加注解。
在 Controller 方法参数前加 @Valid。
Service 层只处理业务逻辑，不再处理参数清洗。

C. 职责分离
现状：
AuthenticationService
 既管登录，又管“重置密码”。
改进：
AuthService：只负责 login (颁发 Token) 和 refreshToken。
AccountService：负责 
resetPassword
, updateProfile 等账号管理操作。

D. 利用 Spring Security 链
现状：在 Service 中手动调用 authenticationManager.authenticate 是可以的，但部分前置检查（如账号是否锁定）可以完全交给 Spring Security 的 UserDetails 实现，Service 层只需捕获异常即可，代码会更简洁。


 🛠️ 改进方向：登录校验代码 (AuthenticationService)
你提到的 
AuthenticationService
 确实存在耦合度高和冗余的问题。以下是具体的重构建议（目前先不改动代码，供后续优化参考）：

A. 移除 HttpSession (无状态化)
问题: 目前代码使用 session.setAttribute("verificationCode", ...) 存储验证码。这会导致服务无法水平扩展（因为 Session 默认存储在单机内存中）。
方案: 改用 Redis 存储验证码。
Key: auth:code:{email}
Value: 验证码
TTL: 设置5分钟过期
这样不仅支持分布式部署，还能利用 Redis 的过期机制自动清理。
B. 参数校验层级分离
问题: Service 层充斥着大量的 if (email == null) 等防御性代码，污染了业务逻辑。
方案: 使用 Spring Validation (@Valid, @NotBlank)。
在 UserDTO 或请求对象中添加注解。
在 Controller 层自动拦截非法请求。
Service 层默认接收到的数据就是合法的，专注于业务处理。
C. 职责单一原则 (SRP)
问题: 
AuthenticationService
 目前既管“登录鉴权”，又管“密码重置”、“验证码发送”。
方案: 拆分服务。
AuthService: 仅负责 登录 (login)、刷新 Token (refreshToken)、登出 (logout)。
AccountService (或 UserService): 负责 找回密码 (
resetPassword
)、修改密码、绑定邮箱等账号维度的操作。
D. 异常处理机制
问题: 方法内部大量 try-catch 并返回 Result.error()，导致调用方难以通过异常流控制逻辑。
方案: 使用 全局异常处理。
Service 层遇到错误直接抛出自定义异常（如 BusinessException("验证码错误")）。
由 GlobalExceptionHandler 统一捕获并封装成 Result 返回给前端。