# 聊天功能完整修复总结

## 修复时间
2025-12-17 18:40

## 核心问题

### 1. 消息不在聊天详情显示
**原因**: `messages` Map 使用 `number` 作为键，但在存储时使用了 `parseInt` 转换大整数，导致精度丢失。键不匹配，所以 `currentMessages` 获取不到消息。

**修复**: 将 `messages` 的类型从 `Map<number, MessageVO[]>` 改为 `Map<string, MessageVO[]>`，统一使用字符串作为键。

### 2. 刷新后聊天记录消失
**原因**: 消息虽然通过 WebSocket 发送成功，但可能没有正确持久化到数据库，或者没有从数据库加载。

**需要验证**: 
- 后端是否正确保存消息到数据库
- `loadChatHistory` 是否正确加载历史消息

### 3. 对方收不到实时消息
**原因**: 
1. 前端发送时使用 `parseInt` 导致 receiverId 精度丢失
2. 后端使用 receiverId 查找用户时找不到（ID错误）

**修复**: 
- 前端直接发送字符串 ID，不使用 `parseInt`
- 后端 Jackson 会自动将字符串反序列化为 Long

## 详细修复内容

### 前端修复 (chat.ts)

#### 1. 修改 Map 和 Set 的键类型
```typescript
// ❌ 之前
const messages = ref<Map<number, MessageVO[]>>(new Map())
const typingUsers = ref<Set<number>>(new Set())

// ✅ 现在
const messages = ref<Map<string, MessageVO[]>>(new Map())
const typingUsers = ref<Set<string>>(new Set())
```

#### 2. 修改 currentMessages 计算属性
```typescript
// ❌ 之前：使用 parseInt 导致精度丢失
const userId = typeof currentConversation.value.otherUserId === 'string'
    ? parseInt(currentConversation.value.otherUserId)
    : currentConversation.value.otherUserId

// ✅ 现在：统一转换为字符串
const userId = currentConversation.value.otherUserId.toString()
```

#### 3. 修改 handleNewMessage
```typescript
// ❌ 之前：使用 parseInt
const otherUserIdNum = typeof otherUserId === 'string' ? parseInt(otherUserId) : otherUserId
messages.value.set(otherUserIdNum, userMessages)

// ✅ 现在：使用字符串
const otherUserIdStr = otherUserId.toString()
messages.value.set(otherUserIdStr, userMessages)
```

#### 4. 修改 loadChatHistory
```typescript
// API 调用仍然需要数字（后端接口参数）
const otherUserIdNum = typeof otherUserId === 'string' ? parseInt(otherUserId) : otherUserId
const data = await chatApi.getChatHistory(otherUserIdNum, page, 50)

// ✅ 但存储时使用字符串
messages.value.set(otherUserId.toString(), sortedMessages)
```

#### 5. 修改 sendMessage
```typescript
// ❌ 之前：转换为数字导致精度丢失
const receiverIdNum = typeof receiverId === 'string' ? parseInt(receiverId) : receiverId
webSocketService.sendMessage(receiverIdNum, content.trim())

// ✅ 现在：直接发送原始值
webSocketService.sendMessage(receiverId, content.trim())
```

### WebSocket 服务修复 (websocket.ts)

```typescript
// 修改函数签名支持 string | number
sendMessage(receiverId: number | string, content: string, messageType: string = 'TEXT')
sendTyping(receiverId: number | string)
```

### 后端修复 (ChatWebSocketController.java)

#### 1. 添加在线用户调试
```java
@Autowired
private SimpUserRegistry userRegistry;

// 打印所有在线用户
log.info("当前在线用户数: {}", userRegistry.getUserCount());
userRegistry.getUsers().forEach(user -> {
    log.info("- 在线用户: {}", user.getName());
});
```

#### 2. 使用用户名发送消息
```java
// ❌ 之前：使用用户ID
messagingTemplate.convertAndSendToUser(
    messageDTO.getReceiverId().toString(),
    "/queue/messages",
    messageVO);

// ✅ 现在：使用用户名
com.flowbrain.viewx.pojo.entity.User receiver = userService.getUserById(messageDTO.getReceiverId()).getData();
if (receiver != null) {
    messagingTemplate.convertAndSendToUser(
        receiver.getUsername(),  // 使用用户名
        "/queue/messages",
        messageVO);
}
```

## 测试步骤

### 1. 重启后端服务
**重要**: 必须重启后端才能应用修改！

### 2. 刷新前端页面
按 `Ctrl + Shift + R` 强制刷新

### 3. 测试消息显示
1. 登录用户A
2. 给用户B发送消息
3. **预期结果**: 
   - 消息立即显示在右侧聊天详情窗口
   - 消息显示在左侧会话列表预览中

### 4. 测试刷新后的持久化
1. 发送几条消息
2. 刷新页面 (F5)
3. **预期结果**: 
   - 聊天历史应该自动加载
   - 之前的消息应该显示

### 5. 测试实时接收
1. 打开两个浏览器窗口
2. 分别登录用户A和用户B
3. 用户A给用户B发送消息
4. **预期结果**: 
   - 用户B立即收到消息
   - 消息显示在用户B的聊天详情窗口

### 6. 查看后端日志
应该看到：
```
=== 开始处理消息发送 ===
当前在线用户数: 2
- 在线用户: userA
- 在线用户: userB
发送者用户名: userA
接收者ID: 1996231987635134464
消息内容: Hello
接收者用户名: userB
✅ 消息已发送给接收者: 1996231987635134464 (用户名: userB)
```

### 7. 查看前端控制台
应该看到：
```
chatStore: 发送消息给: 1996231987635134464
📤 WebSocket 发送消息: {receiverId: "1996231987635134464", content: "Hello", type: "string"}
📨 处理新消息: {id: ..., senderId: ..., receiverId: "1996231987635134464", ...}
是我发送的: true 对方用户ID: 1996231987635134464
字符串ID: 1996231987635134464
✅ 消息已添加到列表，当前消息数: 1
当前 messages Map 的所有键: ["1996231987635134464"]
📬 currentMessages: 会话ID= 1996231987635134464 消息数= 1
```

## 关键点总结

### ✅ 已修复
1. **消息显示问题**: 使用字符串作为 Map 键，避免精度丢失
2. **消息发送问题**: 直接发送字符串 ID，不使用 parseInt
3. **WebSocket 路由**: 使用用户名而不是用户ID
4. **调试日志**: 添加了详细的前后端日志

### ⚠️ 需要验证
1. **数据库持久化**: 确认消息是否正确保存到数据库
2. **历史加载**: 确认 `loadChatHistory` 是否正确工作
3. **后端是否重启**: 必须重启后端服务

## 常见问题

### Q: 消息还是不显示？
A: 检查浏览器控制台的日志，看看：
- `messages Map 的所有键` 是什么
- `currentMessages: 会话ID` 是什么
- 两者是否匹配

### Q: 刷新后消息消失？
A: 检查：
- 后端日志，看消息是否保存到数据库
- `loadChatHistory` 是否被调用
- API 返回的数据是否正确

### Q: 对方还是收不到？
A: 检查后端日志：
- 在线用户列表中是否有接收者
- 接收者的用户名是什么
- 是否有 "消息已发送给接收者" 的日志

## 相关文件

### 前端
- `src/stores/chat.ts` - 聊天状态管理（主要修改）
- `src/utils/websocket.ts` - WebSocket 服务
- `src/api/index.ts` - API 类型定义
- `src/views/Messages.vue` - 消息页面
- `src/components/chat/MessageItem.vue` - 消息项组件

### 后端
- `controller/ChatWebSocketController.java` - WebSocket 控制器（主要修改）
- `config/WebSocketConfig.java` - WebSocket 配置
- `service/ChatService.java` - 聊天服务
