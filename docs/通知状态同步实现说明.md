# 通知状态同步实现说明

## 目标
实现右上角通知铃铛和左侧通知中心页面的状态同步，当一个地方进行操作（删除、标记已读）时，另一个地方也能实时更新。

## 已完成
✅ 创建了 `notification.ts` store，统一管理通知状态
✅ 导出了 store 到 `stores/index.ts`

## 需要手动修改的文件

### 1. `NotificationBell.vue`

将组件改为使用 notification store：

```vue
<script setup lang="ts">
import { ref, onMounted, onUnmounted, computed } from 'vue'
import { Bell, X } from 'lucide-vue-next'
import { type NotificationVO } from '@/api'
import { useRouter } from 'vue-router'
import { useNotificationStore } from '@/stores'

const router = useRouter()
const notificationStore = useNotificationStore()

const showDropdown = ref(false)

// 使用 store 中的状态
const loading = computed(() => notificationStore.loading)
const unreadCount = computed(() => notificationStore.unreadCount)
const notifications = computed(() => notificationStore.notifications.slice(0, 10))

// 删除本地的 loading, unreadCount, notifications 变量声明

// 修改 fetchNotifications 为调用 store
const toggleDropdown = () => {
  showDropdown.value = !showDropdown.value
  if (showDropdown.value) {
    notificationStore.fetchNotifications({ page: 1, pageSize: 10 })
  }
}

// 修改 fetchUnreadCount
const fetchUnreadCount = async () => {
  await notificationStore.fetchUnreadCount()
}

// 修改 markAllAsRead
const markAllAsRead = async () => {
  try {
    await notificationStore.markAllAsRead()
  } catch (e) {
    console.error('Failed to mark all as read', e)
  }
}

// 修改 handleNotificationClick
const handleNotificationClick = async (notification: NotificationVO) => {
  showDropdown.value = false
  
  if (!notification.isRead) {
    try {
      await notificationStore.markAsRead(notification.id)
    } catch (e) {
      console.error('Failed to mark as read', e)
    }
  }

  if (notification.relatedVideoId) {
    router.push(`/video/${notification.relatedVideoId}`)
  } else if (notification.senderId) {
    router.push(`/profile/${notification.senderId}`)
  }
}

// 修改 deleteNotification
const deleteNotification = async (id: number) => {
  try {
    await notificationStore.deleteNotification(id)
  } catch (e) {
    console.error('Failed to delete notification', e)
  }
}
</script>
```

### 2. `Notifications.vue`

同样改为使用 notification store：

```vue
<script setup lang="ts">
import { ref, onMounted, inject, type Ref, computed } from 'vue'
import { useRouter } from 'vue-router'
import { Bell, ArrowLeft, X } from 'lucide-vue-next'
import { type NotificationVO, type NotificationType } from '@/api'
import { ElMessage } from 'element-plus'
import { useNotificationStore } from '@/stores'

const router = useRouter()
const isMobile = inject<Ref<boolean>>('isMobile', ref(false))
const notificationStore = useNotificationStore()

// 使用 store 中的状态
const loading = computed(() => notificationStore.loading)
const unreadCount = computed(() => notificationStore.unreadCount)
const notifications = computed(() => notificationStore.notifications)

// 删除本地的 loading, unreadCount, notifications 变量声明

const page = ref(1)
const pageSize = 20
const hasMore = ref(true)
const filterType = ref<NotificationType | ''>('')

// 修改 fetchNotifications
const fetchNotifications = async (reset = false) => {
  if (reset) {
    page.value = 1
    hasMore.value = true
  }

  try {
    const list = await notificationStore.fetchNotifications({
      notificationType: filterType.value || undefined,
      page: page.value,
      pageSize
    })
    
    hasMore.value = list.length === pageSize
  } catch (e) {
    console.error('Failed to fetch notifications', e)
    ElMessage.error('获取通知失败')
  }
}

// 修改 fetchUnreadCount
const fetchUnreadCount = async () => {
  await notificationStore.fetchUnreadCount()
}

// 修改 markAllAsRead
const markAllAsRead = async () => {
  try {
    await notificationStore.markAllAsRead()
    ElMessage.success('已全部标记为已读')
  } catch (e) {
    console.error('Failed to mark all as read', e)
    ElMessage.error('操作失败')
  }
}

// 修改 handleNotificationClick
const handleNotificationClick = async (notification: NotificationVO) => {
  if (!notification.isRead) {
    try {
      await notificationStore.markAsRead(notification.id)
    } catch (e) {
      console.error('Failed to mark as read', e)
    }
  }

  if (notification.relatedVideoId) {
    router.push(`/video/${notification.relatedVideoId}`)
  } else if (notification.senderId) {
    router.push(`/profile/${notification.senderId}`)
  }
}

// 修改 deleteNotification
const deleteNotification = async (id: number) => {
  try {
    await notificationStore.deleteNotification(id)
    ElMessage.success('已删除通知')
  } catch (e) {
    console.error('Failed to delete notification', e)
    ElMessage.error('删除失败')
  }
}
</script>
```

## 工作原理

1. **统一状态管理**：所有通知相关的状态（列表、未读数）都存储在 `notification` store 中
2. **响应式更新**：使用 `computed` 从 store 中获取数据，当 store 更新时，所有使用该数据的组件都会自动更新
3. **操作同步**：所有操作（删除、标记已读）都通过 store 的方法进行，确保状态一致性

## 效果

- 在右上角铃铛删除通知 → 左侧通知中心页面立即更新
- 在通知中心页面删除通知 → 右上角铃铛的未读数和列表立即更新
- 标记已读操作也是同样的效果

## 注意事项

由于涉及大量代码修改，建议：
1. 先备份当前文件
2. 逐步替换，测试每一步
3. 确保 import 语句正确
4. 删除不再使用的本地状态变量
